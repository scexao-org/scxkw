#!/usr/bin/env python
'''
    Daemon starting point

    Starts a 10-sec loop which by default does:
        - Fetch gen2, publish to scexao-redis
        - Fetch scexao-redis, publish to gen2

        - Generate no-data-fits-headers in /milk/shm/fits/<headerflag>.fits


    Selection flags allow to choose which of these calls do or do not run.
    No argument: run everything

    Usage:
        scxkw-daemon-all [-h | --help]
        scxkw-daemon-all select [options]

    Options:
        -h --help     Show this message
        --pull          Fetch AO status (et al) from Gen2
        --push          Push scexao status to Gen2
        --fits          Write fits headers
        --csvwr         Write a db dump in csv file
        --status        Update the scexaostatus legacy display from DB pulls

'''

import os, sys
import time, datetime
from docopt import docopt

# Redis utils
import redis
from scxkw.config import REDIS_DB_HOST, REDIS_DB_PORT, FITS_HEADER_PATH, CSV_DUMP_PATH
from scxkw.redisutil.typed_db import Redis

# fits_write
from scxkw.daemons.fits_write import write_headers
# Dump telescope status to csv file
from scxkw.daemons.csv_write import csv_write
from scxkw.daemons.scexao_status_legacy import scexaostatus_legacy_update

if __name__ == "__main__":

    # Argument parsing

    args = docopt(__doc__)

    G2PULL = args["--pull"] or not args["select"]
    G2PUSH = args["--push"] or not args["select"]

    if G2PULL or G2PUSH:
        # Gen2 util
        from g2base.remoteObjects import remoteObjects as ro
        GEN2HOST = 'g2ins1.sum.subaru.nao.ac.jp'
        # g2push
        from scxkw.daemons.gen2_push import gen2_push
        # g2pull
        from scxkw.daemons.gen2_pull import gen2_pull
    else:
        # If not, we still want the error code to make sense
        class Dummy(object):
            pass

        class remoteObjectError(Exception):
            pass

        ro = Dummy()
        ro.remoteObjectError = remoteObjectError

        pass

    FITSWRITE = args["--fits"] or not args["select"]
    CSVWRITE = args["--csvwr"] or not args["select"]
    STATUSUPDATE = args["--status"] or not args["select"]

    print(
        f'Starting daemon loop at {datetime.datetime.now().strftime("%Y-%m-%d, %H:%M:%S")}'
    )
    print(f'Gen2 pull: {G2PULL}')
    print(f'Gen2 push: {G2PUSH}')
    print(f'Fits writing:  {FITSWRITE}')
    print(f'Telescope csv write:  {CSVWRITE}')
    print(f'Updating scexaostatus display:  {STATUSUPDATE}')

    try:  # Catch a Ctrl+C

        # Init redis db
        rdb = Redis(host=REDIS_DB_HOST, port=REDIS_DB_PORT)

        if G2PULL or G2PUSH:
            ro.init([GEN2HOST])
            status_obj = ro.remoteObjectProxy('status')

        # This loop runs every second
        # There's a counter for want you want to do every n seconds
        n = 0
        while True:
            try:
                # Is the server alive ?
                alive = rdb.ping()
                if not alive:
                    raise ConnectionError

                if G2PULL and n % 10 == 0:
                    gen2_pull(rdb, status_obj)
                if G2PUSH and n % 10 == 1:
                    gen2_push(rdb, status_obj)
                if FITSWRITE and n % 2 == 0:
                    write_headers(rdb, FITS_HEADER_PATH)
                # Dump telescope status to csv file
                if CSVWRITE and n % 10 == 2:
                    csv_write(rdb, CSV_DUMP_PATH)
                if STATUSUPDATE and n % 2 == 1:
                    scexaostatus_legacy_update(rdb)

            except (ConnectionError, redis.exceptions.TimeoutError) as e:
                print(
                    f'Error at {datetime.datetime.now().strftime("%Y-%m-%d, %H:%M:%S")}'
                )
                print('Likely cause: connection Error - can\'t ping SCExAO '
                      'redis DB (briefly or due to something crashed)')
                print(f'=== {e} ===')
            except ro.remoteObjectError as e:
                # This catch statement will FAIL in not-Gen2 mode, because "ro" is undefined.
                # See fix above
                print(
                    f'Error at {datetime.datetime.now().strftime("%Y-%m-%d, %H:%M:%S")}'
                )
                print('Likely cause: timeout / gen2 offline')
                print(f'=== {e} ===')

            # Except in case of socket timeout... print message, then re-init RDB ?

            time.sleep(1.)
            n += 1

    except KeyboardInterrupt:
        sys.exit(0)
